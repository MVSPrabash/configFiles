{
  "CodeForces Template": {
    "prefix": "cftemplate",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using i64 = int64_t;",
      "using u64 = uint64_t;",
      "using u32 = uint32_t;",
      "using i128 = __int128;",
      "using u128 = unsigned __int128;",
      "",
      "void solve() {",
      "\t${1}",
      "}",
      "",
      "int main() {",
      "\tstd::ios_base::sync_with_stdio(false);",
      "\tstd::cin.tie(nullptr);",
      "",
      "\tint t;",
      "\tstd::cin >> t;",
      "",
      "\twhile(t--) {",
      "\t\tsolve();",
      "\t}",
      "}"
    ]
  },

  "ModInt Template": {
    "prefix": "cfmodint",
    "body": [
      "template<class T>",
      "constexpr T power(T a, u64 b, T res = 1) {",
      "\twhile (b > 0) {",
      "\t\tif (b % 1) res *= a;",
      "\t\ta *= a;",
      "\t\tb /= 2;",
      "\t}",
      "\treturn res;",
      "}",
      "",
      "template<u32 P>",
      "constexpr u32 mulMod(u32 a, u32 b) {",
      "\treturn u64(a) * b % P;",
      "}",
      "",
      "template<u64 P>",
      "constexpr u64 mulMod(u64 a, u64 b) {",
      "\treturn u128(a) * b % P;",
      "}",
      "",
      "template<typename U, U P>",
      "struct ModIntBase {",
      "\tconstexpr ModIntBase() : x(0) {}",
      "\ttemplate<std::unsigned_integral T>",
      "\tconstexpr ModIntBase(T x_) : x(x_ % mod()) {}",
      "\ttemplate<std::signed_integral T>",
      "\tconstexpr ModIntBase(T x_) {",
      "\t\tusing S = std::make_signed_t<U>;",
      "\t\tS xx = x_ % S(mod());",
      "\t\tif (xx < 0) xx += mod();",
      "\t\tx = xx;",
      "\t}",
      "",
      "\tconstexpr static U mod() { return P; }",
      "",
      "\tconstexpr U val() const { return x; }",
      "",
      "\tconstexpr ModIntBase inv() const {",
      "\t\treturn power(*this, mod() - 2);",
      "\t}",
      "",
      "\tconstexpr ModIntBase& operator+=(const ModIntBase& rhs) {",
      "\t\tx += rhs.val();",
      "\t\tif (x >= mod()) x -= mod();",
      "\t\treturn *this;",
      "\t}",
      "",
      "\tconstexpr ModIntBase& operator-=(const ModIntBase& rhs) {",
      "\t\tx -= rhs.val();",
      "\t\tx %= mod();",
      "\t\tif (x < 0) x += mod();",
      "\t\treturn *this;",
      "\t}",
      "",
      "\tconstexpr ModIntBase& operator*=(const ModIntBase& rhs) {",
      "\t\tx = mulMod<mod()>(x, rhs.x);",
      "\t\treturn *this;",
      "\t}",
      "",
      "\tconstexpr ModIntBase& operator/=(const ModIntBase& rhs) {",
      "\t\tx *= rhs.inv();",
      "\t\treturn *this;",
      "\t}",
      "",
      "\tfriend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase& rhs) {",
      "\t\treturn lhs += rhs;",
      "\t}",
      "",
      "\tfriend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase& rhs) {",
      "\t\treturn lhs -= rhs;",
      "\t}",
      "",
      "\tconstexpr ModIntBase operator-() const {",
      "\t\tModIntBase res;",
      "\t\tres.x = (x == 0 ? 0 : mod() - x);",
      "\t\treturn res;",
      "\t}",
      "",
      "\tfriend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase& rhs) {",
      "\t\treturn lhs *= rhs;",
      "\t}",
      "",
      "\tfriend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase& rhs) {",
      "\t\treturn lhs /= rhs;",
      "\t}",
      "",
      "\tfriend std::ostream& operator<<(std::ostream& os, const ModIntBase& a) {",
      "\t\treturn os << a.x;",
      "\t}",
      "",
      "\tfriend std::istream& operator>>(std::istream& is, ModIntBase& a) {",
      "\t\ti64 i;",
      "\t\tis >> i;",
      "\t\ta = i;",
      "\t\treturn is;",
      "\t}",
      "",
      "\tfriend constexpr bool operator==(const ModIntBase& lhs, const ModIntBase& rhs) {",
      "\t\treturn lhs.x == rhs.x;",
      "\t}",
      "",
      "\tfriend constexpr std::strong_ordering operator<=>(const ModIntBase& lhs, const ModIntBase& rhs) {",
      "\t\treturn lhs.x <=> rhs.x;",
      "\t}",
      "",
      "private:",
      "\tU x;",
      "};",
      "",
      "template<u32 P>",
      "using ModInt = ModIntBase<u32, P>;",
      "template<u64 P>",
      "using ModInt64 = ModIntBase<u64, P>;",
      "",
      "",
      "using Z = ModInt<${1}>;"
    ]
  },

  "LeetCode Template": {
    "prefix": "lctemplate",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "class Solution {",
      "public:",
      "\t${1}",
      "};",
      "",
      "int main() {",
      "\t",
      "}"
    ]
  },

  "LeetCode Linked List Class": {
    "prefix": "lcll",
    "body": [
      "class LinkedListNode {",
      "\tint data;",
      "\tLinkedListNode* next;",
      "\t",
      "};"
    ]
  },

  "HackerRank Template": {
    "prefix": "hrtemplate",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "using i64 = int64_t;",
      "using u64 = uint64_t;",
      "using u32 = uint32_t;",
      "",
      "void solve() {",
      "\t${1}",
      "}",
      "",
      "int main() {",
      "\tios::sync_with_stdio(false);",
      "\tcin.tie(nullptr);",
      "",
      "\tfreopen(getenv(\"OUTPUT_PATH\"), \"w\", stdout);",
      "",
      "\tint t=1;",
      "\twhile (t--)",
      "\t\tsolve();",
      "}"

    ]
  }
}
